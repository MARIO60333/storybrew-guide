## Предисловие и Оглавление

**Данный гайд является по большей части переводом официальной вики по данной программе, но с дополнениями от автора. Также для работы с Storybrew вам необходимо знать [основы скриптинга osb](https://osu.ppy.sh/wiki/Storyboard/Scripting) и [основы программирования на C#](https://drive.google.com/file/d/1AsXomRMBenOr5DS0T4VBTlTSf72ZguwM) (если вы знакомы с синтаксисом C-подобных языков, то вам не составит труда работать с C#).**

### Что включено в гайд:

1. [Введение](#введение)

   1. [Начало работы](#начало-работы)
   2. [Интерфейс](#интерфейс)

2. [Предустановленные эффекты](#предустановленные-эффекты)

   1. [HitObjectHighlight](#hitobjecthighlight)
   2. [ImportOsb](#importosb)
   3. [Jigoku](#jigoku)
   4. [Lyric и Karaoke](#lyrics-и-karaoke)
   5. [Particles](#particles)
   6. [RadialSpectrum и Spectrum](#radialspectrum-и-spectrum)
   7. [Tetris](#tetris)

3. [Создание скриптов эффектов](#создание-скриптов-эффектов)

   1. [Методы Sprite](#методы-sprite)
   2. [Звуковые семплы](#звуковые-семплы)
   3. [Данные Beatmap](#данные-beatmap)
   4. [Данные Audio](#данные-audio)
   5. [Создание изменяемых параметров](#создание-изменяемых-параметров)
   6. [Значения по ключевым кадрам](#значения-по-ключевым-кадрам)
   7. [Методы Utility](#методы-utility)
   8. [Lyrics](#lyrics)
   9. [Предупреждения редактора](#предупреждения-редактора)

4. [Заключение и дополнения от автора](#заключение-и-дополнения-от-автора)

## Введение

**В данном гайде будет рассмотрено 2 варианта работы с Storybrew (далее sb/сб), первый - без коддинга и второй с коддингом соответственно. Упор делается на второй вариант, так что мы будем устанавливать sb с необходимыми компонентами и программами для дальнейшей работы.**

### Начало работы

Прежде чем начать работу с sb, нужно скачать и установить его с необходимыми компонентами и программами. Далее последует пошаговое руководство по установки всего.

1. Скачиваем [последнюю версию sb](https://github.com/Damnae/storybrew/releases) (выбираем `storybrew.<версия>.zip`) и распаковываем в удобное место, желательно чтобы путь до корневой папки с программой не содержало кириллицу

2. Установите [Visual Studio Code](https://code.visualstudio.com). Удостоверьтесь, что при установке было выбрано "Добавить в PATH" или установите в стандартную директорию, чтобы sb смог его найти

   Вы можете использовать другую версию Visual Studio, но их установка сложнее. Вы можете использовать любой другой редактор, но при этом будет отсутствовать IntelliSense (автозавершение слов, подсказки параметров и т. д.). Также аргументом "за" служит то, что Storybrew лучше интегрирован с Visual Studio Code

   Также стоит установить расширение С# для Visual Studio Code, чтобы была подсветка кода и корректно работал IntelliSense

3. Установите [.NET Framework 4.5.2 Developer Pack](https://www.microsoft.com/en-us/download/details.aspx?id=42637)

   _Далее рекомендуется перезагрузить систему, прежде чем продолжить._

4. Запускаем `Storybrew Editor.exe` и нажимаем на `New project`

5. Далее мы можем написать желаемое имя проекта и указать директорию мапсета(те. директорию самой карты, выбираем любой _.osu_ файл), после жмем `Start`

Готово, теперь мы находимся непосредственно в редакторе, далее познакомимся с интерфейсом программы

### Интерфейс

Перед нами открыт редактор, черное окно с непонятными для нас кнопками, давайте разберёмся, что за что и какая кнопка отвечает.

![Интерфейс программы](/imgs/1.png)

1. Таймкод - ваше текущее положение на временной шкале, нажав [CTRL+C] с наведенной на нее курсором, вы его скопируйте (в миллисекундах). При зажатом [ALT] покажет координаты курсора на холсте(те в рабочем пространстве)

2. Размерность ноты (шаг временной шкалы) - нажимая, вы изменяете шаг временной шкалы, все также, как в редакторе osu!

3. Скорость - нажимая, вы изменяете скорость воспроизведения

4. Временная шкала. Она разделена на две половинки, верхняя и нижняя. Сверху кнопкой мыши вы можете перемещаться по временной шкале от начала и до конца песни, а снизу, крутя колесо мыши вы будете перемещаться между заданными шагами

5. Название сложности. Sb позволяет делать сториборд для конкретной сложности, но об этом потом

6. Изменить сложность. Нажимая, вызывает диалоговое окно с выбором сложности

7. Режим отображения. Нажимая, изменяет режим отображения сториборда, те растянуть на все окно или подогнать под него

8. Воспроизведение/пауза (используйте пробел для этого)

9. Эффекты. Нажимая, вызывает окно эффектов, где вы их можете создавать/редактировать/переименовывать

10. Слои. Нажимая, вызывает окно слоев, где вы можете перемещать эффекты и задавать некоторые параметры

11. Настройки. Нажимая, вызывает окно настроек, где вы можете вызвать справку, добавить библиотеки и изменить прозрачность сториборда

12. Открыть директорию проекта

13. Открыть директорию мапсета

14. Сохранить проект

15. Экспортировать. Нажимая левой кнопкой мыши, экспортирует сториборд в osb файл мапсета(создает если не было), а нажимая правой кнопкой мыши, экспортирует в osu файл каждой сложности, если указанно, что конкретный эффект для каждой сложности индивидуален

Горячие клавиши:

`[Scroll]` - Перемещение по композиции.

`[Space]` - Переключение воспроизведения/паузы песни.

`[Ctrl-S]` - Сохранение проекта.

`[Ctrl-C]` - Копирует текущее время в миллисекундах в буфер обмена. Удерживайте Shift, чтобы скопировать текущее время в пользовательском формате (по умолчанию h:mm:ss.ff). Этот формат можно изменить в файле settings.cfg.

`[Стрелки вправо/влево]` - Перемещение на один тик в направлении стрелки. Удерживайте `[Shift]`, чтобы переместиться на 4 тика. Удерживайте `[Control]`, чтобы перейти к следующей/предыдущей закладке.

`[Alt]` - Показывать положение курсора в координатах раскадровки вместо текущего времени. Также позволяет видеть раскадровку вне ее обычных границ.

`[Alt + Scroll]` - Изменение громкости звука.

`[O]` - Открыть другой проект.

**Теперь рассмотрим окно эффектов, параметров эффекта и слоев**

![Окно эффектов](/imgs/2.png)

1. Добавить эффект. Нажимая, вызывает диалоговое окно с предустановленными и пользовательскими в проекте эффектами.

   Вы можете добавлять предустановленные эффекты в папку `scripts` в директории программы, чтобы использовать их в других проектах без копирования из других. На самом деле, если вы добавляете новый эффект в проект, то скрипт эффекта копируется в директорию проекта. Если вы создадите свой эффект с теми же названиями, что и предустановленные или измените предустановленные скрипты внутри проекта, то ваш или измененный эффект перекроет предустановленные в диалоговом меню, те при добавлении тех же эффектов, используемые в проекте, они будут вашими или измененными (ред. ну это логично, чи не?)

2. Создать скрипт. Нажимая, вызывает диалоговое окно, где вы можете написать название нового скрипта эффекта. После открывается Visual Studio Code с директорией проекта и начальный шаблон скрипта эффекта

3. Изменить название. Нажимая, вызывает диалоговое окно, где вы можете переименовать выбранный экземпляр эффекта

4. Название экземпляра (те конкретного) эффекта

5. Название скрипта эффекта

6. Изменить параметры эффекта. Нажимая, вызывает окно редактирования доступных параметров эффекта

7. Редактировать скрипт. Нажимая, открывает _Visual Studio Code_ с директорией проекта и выбранным скриптом эффекта для его редактирования

8. Удалить эффект

Также перед кнопкой изменения параметров могут появится дополнительные кнопки. Это кнопка в виде жука - значит в вашем скрипте присутствуют ошибки и нажимая на нее, вы откроете окно, где будет они описаны. И кнопка в виде лепестка - это логи скрипта(позже познакомимся)

**Далее рассмотрим окно параметров эффекта. В данном окне вы можете изменить параметры экземпляра эффекта. Для разных скриптов разные параметры. Здесь мы разберем параметры эффекта `Background`. Чтобы начать, добавьте эффект `Background`, нажав в окне эффектов `Add effect` и найдя его в списке, после вызовите окно параметров, нажав на кнопку изменения параметров (шестеренка)**

![Окно параметров эффектов](/imgs/3.png)

Заголовок окна параметров состоит из названия экземпляра эффекта и названия скрипта эффекта в скобках

Кнопки:

1. Скопировать параметры. Нажимая, вы копируйте все параметры экземпляра эффекта
2. Вставить параметры. Нажимая, вы вставляете все скопированные параметры в данный экземпляр эффекта
3. Закрыть окно параметров

Теперь познакомимся с параметрами и самим эффектом Background.

Данный эффект добавляет спрайт фона, который плавно появляется и исчезает по окончанию эффекта.

Параметры:

> `BackgroundPath` - путь до спрайта фона внутри мапсета, если пусто, то используется спрайт фона из конкретной сложности

> `StartTime` и `EndTime` - начало и конец эффекта (в миллисекундах). Если одинаково, то за конец будет взято время из последней ноты в сложности или конца песни

> `Opacity` - непрозрачность эффекта(спрайта фона), от `0` до `1`, где `0` - полностью прозрачный, а `1` - полностью непрозрачный

> `Random seed` - семя (ред. хах, как в Minecraft) для генератора случайных чисел. Это стандартный параметр для всех скриптов, здесь он не используется (ред. тут скрипт и не нуждается в рандоме, хотя вы можете изменить скрипт и добавить его для чего-то, даже не знаю :D)

**Теперь познакомимся с окном слоев**

![Окно слоев](/imgs/4.png)

1. Перемещение. Зажмите и перетаскивайте экземпляр эффекта между другими эффектами или слоями. Чем ниже эффект, тем "ближе" он к нам, те отрисовывается поверх других

2. Задать тип эффекта. Нажимая, вы изменяете тип эффекта: для конкретной сложности(экспорт в .osu) или для всех сложностей(экспорт в .osb)

3. Показать/скрыть эффект. Нажимая, вы скрываете или показываете эффект на холсте. Если эффект скрыт, то он не экспортируется

4. Слои. Читаем [вики игры](https://osu.ppy.sh/wiki/ru/Storyboard/Scripting/General_Rules) (ред. добавлю только то, что располагая эффекты на слое Overlay, они будут отрисовыватся поверх нот и внутриигровых объектов, используют этот слой например в Aspire картах, таких как **ARCADE_MEMORIES от Jerry** и **Acid Rain от SnowNiN\_**).

## Предустановленные эффекты

**Здесь мы познакомимся с предустановленными эффектами и научимся их настраивать. Мы уже познакомились одним из них, это `Background`, теперь пришел черед других. Необходимо отметить то, что у большинства эффектов параметры повторяются, и по мере изучения мы будем с ними знакомится, в последствии мы будем упускать описание параметров, которые изучили, а также, что при разработке скриптов эффектов стоит называть некоторые параметры аналогично, как и в предустановленных для удобства.**

**Те параметры, которые необходимы для минимальной работы эффекта, мы будем отмечать звездочкой (\*)**

### HitObjectHighlight

Данный эффект добавляет подсветку для нот. Используйте этот скрипт только для стандартного режима игры, он не работает с `taiko`/`mania`/`ctb` (ред. вы можете изменить и дополнить этот скрипт для работы с другими режимами). Не забудте переключить тип в слоях _"индивидуально для каждой сложности"_

Параметры:

> `StartTime`**\***

> `EndTime`**\***

> `BeatDivisor` - Как часто будут перемещаться подсветка при следовании за мячиком слайдера. Например, при значении `1` мячик будет перемещаться каждый такт, `2` - каждые полтакта, `4` - каждую четверть такта и т. д.

> `FadeDuration` - Длительность исчезновения подсветки (значение в миллисекундах)

> `SpritePath`**\*** - Путь до спрайта подсветки в мапсете

> `SpriteScale` - Первоначальный масштаб(размер) спрайта при появлении

### ImportOsb

Очень простой эффект, добавляет готовый сториборд `.osb`. Сториборд необходимо поместить в директорию проекта, а в параметре `Path`**\*** указать путь до него в директории проекта с указанием расширения файла. Не забудьте поместить связанные спрайты в директорию мапсета! В окне слоев появятся слои, связанные с эффектом, такие как `Background`, `Foreground` и т.д.

### Jigoku

Пример скрипта, содержащий весь сториборд для карты [Ikareru Kin no Shishi - G59 от EvilElvis (сейчас Natteke_desu)](https://osu.ppy.sh/s/183628)

### Lyrics и Karaoke

`Lyric`s и `Karaoke` - два почти одинаковых эффекта, разница тут очевидна: `Lyrics` - добавляет текст песни, а `Karaoke` - ну это караоке

Параметры:

> `SubtitlesPath`**\*** - Путь до файла субтитров в директории проекта, может быть `.sbv`, `.srt`, `.ass` или `.ssa`. Их можно сделать с помощью такого инструмента, как `aegisub`

> `FontName` - Название шрифта или путь до него в директории проекта. Предпочтительнее добавлять шрифты в директорию проекта и использовать их имя файла, а не устанавливать в систему.

> `SpritePath` - Директория в мапсете, где будут хранится сгенерированные спрайты эффекта

> `FontSize` - Размер шрифта. Чем больше, тем больше размеры спрайтов => больше `SB Load` (ред. читай osu! вики и не задавай неуместных вопросов)

> `FontScale` - Масштаб(размер) сгенерированных спрайтов на холсте

> `FontColor` - Цвет и прозрачность текста

> `FontStyle` - Стиль шрифта (Regular/**Bold**/_Italic_ и т.д. в зависимости от шрифта)

> `GlowRadius` - Радиус подсветки текста (в пикселях), если `0` - выключено

> `GlowColor` - Аналогично `FontColor`

> `AdditiveGlow` - Переключает режим отображения на аддитивный для подсветки

> `OutlineThickness` - Толщина обводки текста (в пикселях), если `0` - выключено

> `OutlineColor` - Аналогично `FontColor`

> `ShadowThickness` - Толщина тени текста (в пикселях), если `0` - выключено

> `ShadowColor` - Аналогично `FontColor`

> `Padding` - Сколько дополнительного пространства выделяется вокруг текста при его генерации. Должно быть увеличено, если символы выглядят обрезанными (в пикселях)

> `SubtitleY` - Перемещение текста на холсте по оси Y (в пикселях)

> `PerCharacter` - Генерировать ли изображения на символ (рекомендуется для меньшего размера мапсета) или на строку (рекомендуется для некоторых языков, например арабского)

> `TrimTransparency` - Убирать ли лишнюю прозрачность по краям генерируемых изображений. Должно быть всегда включено

> `EffectsOnly` - Нужно ли отрисовать только подсветку, обводку и тень.

> `Debug` - Если включено, рисует фон случайного цвета за сгенерированными спрайтами

> `Origin` - Якорная точка спрайтов. Не имеет реального эффекта, если вы не измените код эффекта.

### Particles

Данный эффект создает частицы (ред. для примера, я использовал этот эффект, чтобы создать направленный эффект скорости из аниме, пока показать не могу, но вы загуглите(позже будет пример))

Параметры:

> `Path`**\*** - Путь до спрайта частицы в директории мапсета

> `StartTime`

> `EndTime`

> `ParticleCount` - Кол-во частиц

> `Scale` - Масштаб(размер) частиц по X и Y

> `Rotation` - Угол поворота спрайта частицы (в градусах)

> `Color`

> `ColorVariance` - Вариативность цветов. Подкрашивает спрайт в разные цвета, чем больше значение, тем больше вариативность, если `0` - только один заданный цвет

> `Additive`

> `SpawnOrigin` - Точка спавна частиц на холсте (в пикселях)

> `SpawnSpread` - Разброс спавна частиц относительно начальной точки (в пикселях)

> `Angle` - Угол направления, куда буду лететь частицы (в градусах)

> `AngleSpread` - Разброс угла направления частиц (в градусах)

> `Speed` - Скорость частиц

> `Lifetime` - Время "жизни" частицы (в миллисекундах)

> `Easing` - Временная функция анимации (см. osu! вики или [Здесь](https://osb.moe/learn/docs/storyboarding/scripting/easing) (ред. у сайта истек сертификат, хотите доверяйте, хотите нет))

> `Random seed`

### RadialSpectrum и Spectrum

Два этих эффекта добавляют радиальный и линейный спектр (а ля эквалайзер, где по частотам прыгают столбики под музыку)

Параметры:

> `StartTime`

> `EndTime`

> `Position` - Координаты, где будет размещен спектр (в пикселях)

> `Width` - Ширина спектра (в пикселях)

> `BeatDivisor` - Как часто будет обновляться размер столбиков в соответствии с песней

> `BarCount` - Кол-во столбиков

> `SpritePath`**\***

> `SpriteOrigin` - Якорная точка спрайта

> `SpriteScale`

> `Scale`

> `Radius`

> `LogScale` - Масштабирует столбцы с помощью функции `log`<sub>`10`</sub>. Увеличение этого значения сделает меньшие столбики более заметными. После изменения этого значения может потребоваться настройка масштаба

> `Tolerance` - Упрощает анимацию столбиков, удаляя команды, которые находятся ближе, чем это значение. Это делается с целью повышения производительности и уменьшения размера `.osb`

> `CommandDecimals` - Сколько десятичных знаков используется при записи команд масштабирования в `.osb`. Это делается для уменьшения размера `.osb`

> `MinimalHeight` - Минимальный размер столбиков

> `FftEasing` - Изменяет способ распределения данных спектра между столбиков. Настройка по умолчанию фокусирует спектр на более интересной части данных спектра

> `FrequencyCutOff` - Частота, выше которой все обрезается (в герцах между `20` - `20000`)

### Tetris

Добавляет эффект... тетриса!? Если вам он и пригодится(что вряд ли), то разбирайтесь сами. (ред. я почитал скрипт, походу это самопроходящийся тетрис под такты музыки, очередной пример от разработчика программы)

## Создание скриптов эффектов

**То, ради чего мы изучаем sb. Здесь будут рассмотрены методы и примеры их использования при создании скриптов эффектов. Давайте изучим пример простого скрипта**

Для начала мы создадим новый скрипт, нажав на кнопку создания скрипта в окне эффектов и назовём его, для примера, `TutorialScript`. После перед нами появится _VS Code_ с начальным шаблоном скрипта:

```csharp
using OpenTK;
using OpenTK.Graphics;
using StorybrewCommon.Mapset;
using StorybrewCommon.Scripting;
using StorybrewCommon.Storyboarding;
using StorybrewCommon.Storyboarding.Util;
using StorybrewCommon.Subtitles;
using StorybrewCommon.Util;
using System;
using System.Collections.Generic;
using System.Linq;

namespace StorybrewScripts
{
    public class TutorialScript : StoryboardObjectGenerator
    {
        public override void Generate()
        {


        }
    }
}
```

Далее внутрь метода Generate добавим следующий код и сохраним скрипт

```csharp
var layer = GetLayer("Main"); // Получаем слой с названием "Main"
var bg = layer.CreateSprite("bg.jpg", OsbOrigin.Centre); // Создаем спрайт, первый аргумент - путь до файла спрайта в дирректории мапсета, второй - Якорная точка спрайта, здесь она по центру спрайта
bg.Scale(0, 480.0 / 768); // Масштабируем спрайт, первый аргумент - время, второй - значение масштаба
bg.Fade(0, 2000, 0, 1); // Плавное появление спрайта, 1 арг. - начало в мс, 2 - конец в мс, 3 - нач. знач, 4 - кон. знач.
bg.Fade(8000, 10000, 1, 0); // Плавное затухание спрайта
```

Теперь на холсте появился спрайт фона, который появляется 2 секунды от начала музыки и затухает столько же с 8 секунды

### Методы Sprite

#### Создание спрайта

Перед созданием спрайтов необходимо получить слой с помощью метода `GetLayer(name)`. Слои используются для организации спрайтов эффекта, что позволяет упорядочивать группы спрайтов в редакторе.

Спрайты и анимированные спрайты могут быть созданы из этого слоя с помощью следующих методов (`origin` и `initialPosition` необязательны):

```csharp
CreateSprite(path, origin, initialPosition);
CreateAnimation(path, frameCount, frameDelay, loopType, origin, initialPosition);
```

Где `path` - путь до файла спрайта в директории мапсета, `frameCount` - кол-во кадров, `frameDelay` - время одного кадра, `loopType` - тип цикла анимации, `origin` - якорная точка спрайта, `initialPosition` - начальное положение спрайта

Пример:

```csharp
var layer = GetLayer("Main");
var sprite = layer.CreateSprite("bg.jpg", OsbOrigin.Centre);

// Короткий вариант
var sprite = GetLayer("Main").CreateSprite("bg.jpg", OsbOrigin.Centre);
```

### Изменение спрайтов

#### Перемещение

Изменение положения спрайта во времени. Для `MoveY` доступны команды, аналогичные `MoveX`.

```csharp
Move(easing, startTime, endTime, startPosition, endPosition)
Move(easing, startTime, endTime, startX, startY, endX, endY)
Move(startTime, endTime, startPosition, endPosition)
Move(startTime, endTime, startX, startY, endX, endY)
Move(time, position)
Move(time, x, y)

MoveX(easing, startTime, endTime, startX, endX)
MoveX(startTime, endTime, startX, endX)
MoveX(time, x)
```

#### Масштабирование

Изменение размера спрайта с течением времени. `1` - обычный размер, `0,5` - вдвое меньше, а `2` - вдвое больше обычного.

```csharp
Scale(easing, startTime, endTime, startScale, endScale)
Scale(startTime, endTime, startScale, endScale)
Scale(time, scale)

ScaleVec(easing, startTime, endTime, startScale, endScale)
ScaleVec(easing, startTime, endTime, startX, startY, endX, endY)
ScaleVec(startTime, endTime, startScale, endScale)
ScaleVec(startTime, endTime, startX, startY, endX, endY)
ScaleVec(time, scale)
ScaleVec(time, x, y)
```

#### Поворот

Поворот спрайта во времени. Углы указаны в радианах.

```csharp
Rotate(easing, startTime, endTime, startRotation, endRotation)
Rotate(startTime, endTime, startRotation, endRotation)
Rotate(time, rotation)
```

#### Непрозрачность

Изменение непрозрачности спрайта с течением времени. `1` - полностью видимый, `0` - не видимый.

```csharp
Fade(easing, startTime, endTime, startOpacity, endOpacity)
Fade(startTime, endTime, startOpacity, endOpacity)
Fade(time, opacity)
```

#### Цвет

RGB-раскраска: красный зеленый и синий цвета находятся в диапазоне от `0` до `1`.

```csharp
Color(easing, startTime, endTime, startColor, endColor)
Color(easing, startTime, endTime, startRed, startGreen, startBlue, endRed, endGreen, endBlue)
Color(startTime, endTime, startColor, endColor)
Color(startTime, endTime, startRed, startGreen, startBlue, endRed, endGreen, endBlue)
Color(time, color)
Color(time, red, green, blue)
```

Раскраска HSB: Гораздо более удобное цветовое пространство для выбора цветов, см. [вики](https://en.wikipedia.org/wiki/HSL_and_HSV)

- hue - это угол от `0` до `360°`.
- Красный - около `0/360°`.
- Желтый - около `60°`.
- Зеленый - около `120°`.
- Голубой - около `180°`.
- Синий - около `240°`.
- Розовый - около `300°`.
- Saturation от `0,0` до `1,0`. Переходит от серого цвета при `0` до полностью насыщенного цвета при `1`.
- Brightness от `0,0` до `1,0`. Переходит от черного цвета при `0` до полностью видимого цвета при `1`.

```csharp
ColorHsb(easing, startTime, endTime, startHue, startSaturation, startBrightness, endHue, endSaturation, endBrightness)
ColorHsb(startTime, endTime, startHue, startSaturation, startBrightness, endHue, endSaturation, endBrightness)
ColorHsb(time, hue, saturation, brightness)
```

#### Параметры

Переворачивает спрайт по горизонтали/вертикали или активирует аддитивный режим.

```csharp
FlipH(startTime, endTime)
FlipV(startTime, endTime)
Additive(startTime, endTime)
```

#### Циклы

Повторять команды loopCount раз, пока не будет вызвана функция `EndGroup()`. Время выполнения команд внутри цикла относительно времени начала цикла.

```csharp
LoopCommand StartLoopGroup(startTime, loopCount)
```

Пример:

```csharp
sprite.StartLoopGroup(0, 10);
    sprite.Fade(0, 500, 1, 0);
    sprite.Fade(500, 1000, 0, 1);
sprite.EndGroup();
```

Про команду цикла на [osu! вики](<https://osu.ppy.sh/wiki/Storyboard/Scripting/Compound_Commands#loop-(l)-command>)

#### Триггеры

Команды, объявленные до вызова `EndGroup()`, будут активны на спрайте, когда произойдет событие `triggerName`. Время выполнения команд внутри цикла относительно времени срабатывания триггера.

```csharp
TriggerCommand StartTriggerGroup(triggerName, startTime, endTime, group)
```

Пример:

```csharp
sprite.StartTriggerGroup("HitSoundFinish", 0, 10000);
    sprite.Fade(0, 500, 1, 0);
sprite.EndGroup();
```

Про команду триггер на [osu! вики](<https://osu.ppy.sh/help/wiki/Storyboard_Scripting/Compound_Commands#trigger-(t)-command>)

#### Easings

Вместо того чтобы использовать числа для изменения временной функции, перечисление содержит именованные значения:

```csharp
sprite.Fade(OsbEasing.In, 0, 500, 1, 0); // вместо 2
```

IntelliSense Visual Studio Code покажет полный список значений временных функций при наборе OsbEasing. Этот список также можно найти в файле [`OsbSprite.cs`](https://github.com/Damnae/storybrew/blob/master/common/Storyboarding/OsbSprite.cs#L406). Их также можно предварительно просмотреть в [osb.moe's Easing page](https://osb.moe/learn/docs/storyboarding/scripting/easing).

#### Запрос состояния спрайта

Следующие методы можно использовать для получения состояния спрайта в определенный момент времени. Они не учитывают незавершенные циклы (для которых еще не вызвана функция `EndGroup()`) или триггеры.

```csharp
PositionAt(time)
ScaleAt(time)
RotationAt(time)
OpacityAt(time)
ColorAt(time)
AdditiveAt(time)
FlipHAt(time)
FlipVAt(time)
```

### Звуковые семплы

#### Создание семплов

Семплы можно создать с помощью следующего метода (`volume` необязателен):

```csharp
CreateSample(path, time, volume);
```

Пример:

```csharp
var layer = GetLayer("Main");
layer.CreateSample("sound.wav", 10000, 80);
```

### Данные Beatmap

Информация о битмапах может быть получена скриптами через свойство `Beatmap`.

Название битмапа, используемого скриптами, отображается на временной шкале, переключиться на другой битмап можно, щелкнув правой кнопкой мыши на временной шкале.

#### HitObjects

Вы можете получить информацию, общую для всех типов нот, через свойство `HitObjects` в `Beatmap`.

```csharp
foreach (var hitobject in Beatmap.HitObjects)
{
    var sprite = layer.CreateSprite("sb/pl.png");
    sprite.Fade(hitobject.StartTime, hitobject.EndTime + 200, 1, 0);
    sprite.Move(hitobject.StartTime, hitobject.EndTime, hitobject.Position, hitobject.EndPosition);
}
```

`Hitobjects` могут быть `OsuCircle`, `OsuSlider`, `OsuSpinner` или `OsuHold`. Вот пример того, как получить информацию, которой обладают только ноты определенного типа, например, длину ползунка:

```csharp
var slider = hitobject as OsuSlider;
if (slider != null)
{
    var sliderLength = slider.Length;
    // и т.д.
}
```

Пример использования вы можете найти в скрипте эффекта `HitObjectHighlight`

#### Тайминг и контрольные точки

Все точки синхронизации (только красные линии) можно получить через свойство `TimingPoints` в `Beatmap`. Вы также можете использовать `GetTimingPointAt(time)` для получения точки синхронизации, используемой в определенное время.

Свойство `ControlPoints` и `GetControlPointAt(time)` аналогичны, но возвращают как красные, так и зеленые линии.

#### GetBeatmap

`GetBeatmap(String difficultyName)` позволяет получить `Beatmap`-объект определенной сложности в наборе карт проекта. Использование этой функции гарантирует, что вы работаете в определенном `Beatmap`-объекте, независимо от того, какой объект выбран в данный момент в редакторе. Например:

```csharp
var dummyMap = GetBeatmap("dummy");
var dummyBeatLength = dummyMap.GetTimingPointAt(0).BeatDuration;
```

#### Другие свойства

Свойство `Bookmarks` выводит список времени всех закладок.

Список всех доступных свойств `beatmap` можно найти, набрав `Beatmap.` в своем сценарии.

### Данные Audio

Данные быстрого преобразования Фурье песни можно получить с помощью метода `GetFft(time)` из скриптов. Это вернет массив с количеством магнитуд по умолчанию ("столбики" спектрального эффекта). Вы также можете выбрать количество магнитуд с помощью метода `GetFft(time, magnitudes)`.
Пример использования вы можете найти в скриптах эффектов `RadialSpectrum` и `Spectrum`

### Создание изменяемых параметров

#### Параметры эффектов

Вместо того чтобы создавать множество одинаковых эффектов с немного разными значениями, один и тот же эффект можно использовать несколько раз, настроив его.

Щелчок по значку шестеренки в окне эффектов открывает параметры данного эффекта. Изменение параметров эффекта приведет к его обновлению с новым значением.

По умолчанию все эффекты имеют параметр случайного семени. Это позволяет изменить последовательность случайных чисел, возвращаемых вызовами метода `Random()` скрипта. Различные эффекты могут иметь дополнительные параметры, как в примере `Spectrum`.

#### Создание настраиваемых эффектов

Публичные поля скрипта можно сделать настраиваемыми, добавив атрибут `[Configurable]` перед методом `Generate`.

```csharp
    [Configurable]
    public int StartTime = 0;
```

Поддерживаются следующие типы: `string`, `int`, `float`, `double`, `bool`, `enum`, `Vector2`, `Vector3`, `Color4`, `OsbOrigin`, `OsbEasing` и `OsbLoopType`.

### Значения по ключевым кадрам

#### Основы ключевых кадров

osu! использует команды для анимации спрайтов. Они имеют формат начальное время, конечное время, начальное значение, конечное значение. Когда у вас есть несколько команд подряд, это означает, что вы часто повторяетесь:

```csharp
sprite.Fade(0, 1000, 0, .5f);
sprite.Fade(1000, 2000, .5f, .7f);
sprite.Fade(2000, 3000, .7f, .3f);
sprite.Fade(3000, 4000, .3f, .1f);
sprite.Fade(4000, 5000, .1f, 0);
```

Ключевые кадры более просты и используют только время и значение. Тот же набор команд будет выглядеть следующим образом:

```csharp
opacity.Add(0, 0)
    .Add(1000, .5f)
    .Add(2000, .7f)
    .Add(3000, .3f)
    .Add(4000, .1f)
    .Add(5000, 0);
```

После определения набора ключевых кадров необходимо преобразовать их в команды. Для этого используется метод `ForEachPair`:

```csharp
opacity.ForEachPair((start, end) => sprite.Fade(start.Time, end.Time, start.Value, end.Value));
```

#### Инициализация

Конструктор для создания значений с ключевыми кадрами выглядит следующим образом:

```csharp
var opacity = new KeyframedValue<float>(interpolate);
```

Параметр `interpolate` указывает `KeyframedValue`, как интерполировать значения между ключевыми кадрами. Его можно оставить равным `null`, если вы не собираетесь вызывать метод `ValueAt(double time)`.

Функции интерполяции можно найти в `StorybrewCommon.Animations.InterpolatingFunctions`:

```csharp
var opacity = new KeyframedValue<float>(InterpolatingFunctions.Float);
```

#### Упрощение ключевых кадров

Ключевые кадры в основном используются для упрощения большого количества команд. Пример этого можно увидеть в скриптах спектра, `Spectrum` и `RadialSpectrum`.

Это упрощение основано на алгоритме Рамера-Дугласа-Пюккера; основная идея заключается в том, чтобы взять значение, наиболее удаленное от линии, если оно дальше порогового значения. Значения, которые находятся достаточно близко, могут быть удалены:

![Демонстрация алгоритма Рамера-Дугласа-Пюккера](/imgs/5.gif)

Для этого используются методы `Simplify1dKeyframes`, `Simplify2dKeyframes`, `Simplify3dKeyframes`. Выбор метода зависит от того, сколько параметров принимает команда:

`MoveX`, `MoveY`, `Rotate`, `Scale` и `Fade` принимают одно значение, поэтому вы будете использовать `Simplify1dKeyframes`.
`Move` и `ScaleVec` принимают два значения, поэтому вы будете использовать `Simplify2dKeyframes`;
Цвет принимает три значения, поэтому вы можете использовать `Simplify3dKeyframes`.
Упрощение ключевых кадров, определенных в примере выше, будет выглядеть следующим образом:

```csharp
opacity.Simplify1dKeyframes(tolerance, val => val);
```

Параметр `tolerance` - это порог расстояния, с которого ключевые кадры могут быть удалены.

Часть `val => val` используется для преобразования значений ключевых кадров в число `float`, с которым работает метод. Поскольку значения уже являются плавающей величиной, делать ничего не нужно. То же самое обычно применяется к `Simplify2dKeyframes`, где необходимые значения уже являются `Vector2`. Если бы вы упрощали цвета, вам пришлось бы преобразовывать значения из `Color4` в `Vector3`:

```csharp
colors.Simplify3dKeyframes(tolerance, val => new Vector3(val.R, val.G, val.B));
```

#### Полный пример opacity

```csharp
using StorybrewCommon.Animations;
using StorybrewCommon.Scripting;

namespace StorybrewScripts
{
    public class OpacitySample : StoryboardObjectGenerator
    {
        public override void Generate()
        {
            var sprite = GetLayer("").CreateSprite("image.png");
            var opacity = new KeyframedValue<float>(null);
            opacity.Add(0, 0)
                .Add(1000, .5f)
                .Add(2000, .7f)
                .Add(3000, .3f)
                .Add(4000, .1f)
                .Add(5000, 0);
            opacity.Simplify1dKeyframes(.3f, val => val);
            opacity.ForEachPair((start, end) => sprite.Fade(start.Time, end.Time, start.Value, end.Value));
        }
    }
}
```

### Методы Utility

#### Логи

Сохраняет сообщение в диалоге эффекта. Журналы обычно используются для лучшего отслеживания ваших переменных и специфического поведения методов, например, для отладки. Ведет себя подобно `println` в других языках программирования.

```csharp
Log(string message)
```

Вы можете найти содержание журнала, щелкнув значок листика рядом с именем сценария в списке эффектов (Он будет заменен значком ошибки, если сценарий не выполнился).

![Демонстрация кнопки логов в окне эффектов](/imgs/6.png)

#### Утверждение

Утверждение - это утверждение, которое ожидает выполнения условия - если условие ложно, то эффект не выполнится и выбросит исключение на нарушающей строке. Вы также можете добавить пользовательское сообщение, чтобы предоставить более подробную информацию о неудаче.

```csharp
Assert(bool condition)
Assert(bool condition, string message)
```

#### Рандом

Генерирует случайное число от `minValue` до `maxValue` эксклюзивно. Также возможны такие вариации, как минимум, максимум или генерация двойных значений. Если указан только максимум, то минимум автоматически будет равен `0`. Чтобы генерировать различные наборы случайных чисел, измените случайное зерно, настраиваемое для эффекта.

```csharp
Random(int minValue, int maxValue)
Random(int maxValue)
Random(float minValue, float maxValue)
Random(float maxValue)
Random(double minValue, double maxValue)
Random(double maxValue)
```

#### Загрузка файлов

sb также поддерживает загрузку файлов изображений, называемых `Bitmaps`, или произвольных файлов. Эти методы помогают в этом.

#### Загрузка Bitmap

sb может загрузить файл изображения и преобразовать его в класс `Bitmap`, как указано в `System.Drawing`. Для получения более подробной информации о классе и о том, чем можно манипулировать, обратитесь к документации MSDN. Поддерживаемые типы файлов: `BMP`, `GIF`, `JPEG`, `PNG`, `TIFF`.

Файлы изображений можно получить из директории проекта или мапсета. Эти методы возвращают растровые изображения, поэтому убедитесь, что у вас есть соответствующая переменная для их присвоения.

```csharp
GetProjectBitmap(string path)
GetMapsetBitmap(string path)
```

Обычно при загрузке файлов файл должен быть утилизирован после завершения работы с ним. Однако нет необходимости утилизировать растровое изображение после завершения работы, так как сценарий сделает это за вас.

Сценарий будет автоматически обновляться, если растровое изображение, открытое таким образом, будет изменено.

#### Загрузка произвольного файла

Открывает файл в режиме только для чтения.

Сценарий автоматически обновится, если файл, открытый таким образом, будет изменен.

```csharp
OpenProjectFile(string path)
OpenMapsetFile(string path)
```

В отличие от растровых изображений, вы несете ответственность за их утилизацию. Вот пример:

```csharp
using (var stream = OpenProjectFile("file.txt"))
using (var reader = new StreamReader(stream, System.Text.Encoding.UTF8))
{
    var contents = reader.ReadToEnd();

    ...
}
```

### Lyrics

![Lyrics](/imgs/7.png)

storybrew может помочь в создании сториборда текста песни, загружая файлы субтитров и автоматически генерируя текстовые спрайты. Пример этого можно найти в скрипте эффекта `Lyrics`.

#### Загрузка субтитров

Субтитры могут быть загружены в ваш сценарий следующим способом:

```csharp
var subtitles = LoadSubtitles(path);
```

Где `path` указывает на файл `.sbv`, `.srt`, `.ass` или `.ssa` в директории вашего проекта (не мапсета!). Это стандартный файл субтитров, который можно сделать с помощью такого инструмента, как `aegisub`. Эти субтитры содержат несколько строк, доступ к которым можно получить таким образом:

```csharp
foreach (var line in subtitles.Lines)
```

Каждая строка имеет свойства `Text`, `StartTime` и `EndTime`.

#### Генерирование спрайтов текста

Сначала нужно объявить шрифт. `spritesPath` - это место, куда будут сохраняться сгенерированные спрайты, например, можно использовать "sb/font":

```csharp
var font = LoadFont(spritesPath, new FontDescription() {
    FontPath = "Verdana",
    FontSize = 26,
});
```

Затем вы можете использовать его для создания текстовых спрайтов:

```csharp
var texture = font.GetTexture("Some text");
var sprite = layer.CreateSprite(texture.Path, OsbOrigin.Centre, new Vector2(320, 400));
```

А используя загруженные ранее субтитры, вы можете отображать тексты песен :

```csharp
foreach (var line in subtitles.Lines)
{
    var texture = font.GetTexture(line.Text);
    var sprite = layer.CreateSprite(texture.Path, OsbOrigin.Centre, new Vector2(320, 400));
    sprite.Fade(line.StartTime - 200, line.StartTime, 0, 1);
    sprite.Fade(line.EndTime - 200, line.EndTime, 1, 0);
}
```

#### Характеристики шрифта

Когда вы объявляете новый шрифт, вы можете указать FontDescription, чтобы помочь отформатировать ваш текстовый спрайт. Параметры со значением по умолчанию являются необязательными.

- `FontPath` - Путь к файлу шрифта, в директории вашего проекта. Вы также можете использовать имя шрифта для шрифтов, установленных в системе, но правильное имя шрифта может быть трудно угадать. _Обязательно._
- `FontSize` - Размер точки шрифта. _Значение по умолчанию `76`._
- `Color` - Цвет шрифта, который принимает объект `Color4`. _Значение по умолчанию - черный._
- `Padding` - Пустое пространство в пикселях вокруг отрисованного текстового спрайта, как `Vector2`. Полезно для выравнивания текстового спрайта на фоне с рамкой. _Значение по умолчанию - ноль._

### Предупреждения редактора

Предупреждения появляются, когда storybrew обнаруживает потенциальную проблему производительности или ошибку, которая может привести к поломке вашего сториборда. Эти предупреждения не обязательно означают наличие проблемы, но предупреждают вас о том, на что вы можете обратить внимание.

Числа, используемые ниже, являются пороговыми значениями, при которых начинают появляться эти предупреждения.

#### Производительность

#### 1500 Sprites

Происходит рендеринг большого количества спрайтов. Обычно это не проблема, пока она не становится очень высокой.

#### 15000 Commands

Обрабатывается большое количество команд. Команды - самая дорогая часть сториборда, и лучший способ повысить производительность - уменьшить количество команд, обрабатываемых в каждом кадре.

Спрайты активны с момента начала их первой команды до момента окончания их последней команды. Пока спрайт активен, обрабатываются ВСЕ его команды. Способ уменьшить это число - разделить спрайты с большим количеством команд на несколько спрайтов с меньшим количеством команд.

#### 5000 (50%) Commands on Hidden Sprites

Выполняется много команд, но эти команды находятся на спрайтах, которые не видны.

Спрайты активны с момента начала первой команды до момента окончания последней команды. Пока спрайт активен, обрабатываются ВСЕ его команды. Это верно даже для спрайтов, которые не видны. Способ уменьшить это число - прекратить использование спрайта, пока он не виден, а затем создать новый спрайт, когда он снова станет видимым.

#### 5x Screen Fill

Сколько раз экран был заполнен пикселями. Это то, что osu! называет "SB Load", но это измеряется гораздо более точно.

Способ уменьшить этот показатель - убрать ненужную прозрачность спрайтов, а также убедиться, что спрайты, которые маскируются другими спрайтами поверх них, затухают.

#### Ошибки

#### Overlapped Commands

Команда определенного типа начинается до завершения предыдущей команды.

Например:

```
S,0,1000,3000,0,1.0
S,0,2000,4000,1.0,0
```

Размер спрайтов между 2000 мс и 3000 мс не определен, поскольку в этот период активны обе команды.

#### Incompatible Commands

Спрайт содержит команды, которые нельзя использовать вместе. Спрайт может вести себя по-разному в osu!, а иногда может вести себя по-разному в зависимости от частоты кадров.

Команды, которые нельзя использовать на одном спрайте:

- `Move` с `MoveX` или `MoveY`.
- `Scale` с `ScaleVec`.

## Заключение и дополнения от автора

**Вот и прошел для вас _"курс молодого бойца"_ в сей чудесной программе. В течении изучения вы должны были познакомится как с самой программой, так и коддингом скриптов эффектов в ней. Дальше вы можете скачать и познакомится с моими кастомными скриптами, которые я использую в своих проектах. Но вы меня извините, я мог местами наговнокодить и не оставил документации(мне лень, всю ночь просидел, переводя вики и дополняя ее для сервера), ибо сам я не знаю C#, но оно как-то работает и даже сказал бы я хорошо. До знакомства с sb я был знаком ток c JavaScrip, и у меня не было каких либо проблем освоить минимально C# в тех пределах, в которых я смогу работать**

**Если ты! Да! Именно ты, мой маленький маппер(сторибордер)-извращенец, благодаришь меня за сей труд, то лучшей наградой для меня будет копеечка в карман бедного студента. Раз ты решился, то вот тебе ссылочка на донат:**
https://pay.mysbertips.ru/22963045

Ссылка на репозиторий скриптов:
https://mario60333.github.io/
